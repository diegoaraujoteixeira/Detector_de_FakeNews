# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yk47MYwNCxa4LBlKllhJaZCF1LtLguA0
"""

import streamlit as st
import tensorflow as tf
from tensorflow.keras.layers import TextVectorization, Embedding, GlobalAveragePooling1D, Dense, Dropout, BatchNormalization
from tensorflow.keras.models import load_model, Sequential # Importar Sequential para recriar o TextVectorization
import numpy as np
import pandas as pd # Para exibir probabilidades em DataFrame, similar ao seu exemplo
import json
import os # Para verificar se os arquivos existem

# --- Fun√ß√µes de Carregamento (usando st.cache_resource para performance) ---

# Reconstru√ß√£o da camada TextVectorization
# https://www.tensorflow.org/text/api_docs/python/tf/keras/layers/TextVectorization#get_config
# A camada TextVectorization precisa ser recriada manualmente para carregar os pesos
@st.cache_resource
def load_and_adapt_text_vectorizer(vectorizer_config_path):
    # Verifica se o arquivo de configura√ß√£o do vetorizador existe
    if not os.path.exists(vectorizer_config_path):
        st.error(f"Erro: Arquivo '{vectorizer_config_path}' n√£o encontrado.")
        st.error(f"Por favor, execute o script 'model_trainer.py' primeiro para gerar os arquivos do modelo.")
        st.stop() # Para a execu√ß√£o do Streamlit se o arquivo n√£o existe

    with open(vectorizer_config_path, 'r') as f:
        config_data = json.load(f)

    # Cria uma nova inst√¢ncia de TextVectorization com a configura√ß√£o salva
    loaded_vectorizer = TextVectorization.from_config(config_data['config'])

    # Adapta a camada com um dado 'mock' e ent√£o define os pesos (vocabul√°rio)
    # Isso √© necess√°rio para que a camada esteja totalmente inicializada com o vocabul√°rio correto.
    mock_data = tf.data.Dataset.from_tensor_slices(["a b c"]).batch(1)
    loaded_vectorizer.adapt(mock_data)
    loaded_vectorizer.set_weights(config_data['weights'])

    return loaded_vectorizer

@st.cache_resource # st.cache_resource √© para modelos e objetos complexos
def load_trained_news_model(model_path):
    # Verifica se o arquivo do modelo existe
    if not os.path.exists(model_path):
        st.error(f"Erro: Arquivo '{model_path}' n√£o encontrado.")
        st.error(f"Por favor, execute o script 'model_trainer.py' primeiro para gerar os arquivos do modelo.")
        st.stop() # Para a execu√ß√£o do Streamlit se o arquivo n√£o existe

    # Carrega o modelo Keras. compile=False evita recompilar se o otimizador n√£o estiver dispon√≠vel
    model = load_model(model_path, compile=False)
    # Recompile o modelo com o otimizador original para garantir que ele esteja pronto para previs√£o
    # Assegure que a learning_rate seja a mesma usada no treino (0.0005 no seu model_trainer.py)
    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.0005),
                  loss='binary_crossentropy',
                  metrics=['accuracy'])
    return model

# --- Fun√ß√£o de Previs√£o para o Modelo de Not√≠cias ---
def predict_news_sentiment(model_instance, text_vectorizer_instance, news_text):
    # Pr√©-processar o texto de entrada usando o TextVectorizer adaptado
    # tf.constant([news_text]) cria um tensor de uma √∫nica string, como esperado pelo vetorizador
    vectorized_text = text_vectorizer_instance(tf.constant([news_text]))

    # Fazer a previs√£o (o modelo retorna uma probabilidade entre 0 e 1)
    prediction_prob = model_instance.predict(vectorized_text)[0][0] # [0][0] para obter o float da probabilidade

    # Definir as classes e suas probabilidades para exibi√ß√£o (similar ao seu exemplo de imagem)
    # 0 = Falsa, 1 = Real
    classes = ['Falsa', 'Real']
    # Probabilidades em porcentagem
    probabilities = [ (1 - prediction_prob) * 100, prediction_prob * 100 ]

    df_results = pd.DataFrame()
    df_results['Classes'] = classes
    df_results['Probabilidades (%)'] = probabilities

    # Exibir o resultado principal
    predicted_class = "REAL" if prediction_prob > 0.5 else "FALSA"

    return predicted_class, prediction_prob, df_results

# --- Fun√ß√£o Principal do Aplicativo Streamlit ---
def main():
    st.set_page_config(page_title="Detector de Not√≠cias Falsas")

    st.title('üì∞ Detector de Not√≠cias Falsas')
    st.markdown("Use este aplicativo para verificar se uma not√≠cia √© provavelmente **FALSA** ou **REAL**.")

    # --- Carregar o TextVectorizer e o Modelo ---
    st.info("Carregando modelo e vetorizador... Isso pode levar alguns segundos na primeira vez.")
    # Caminhos para os arquivos que devem ser gerados pelo model_trainer.py
    MODEL_PATH = 'fake_news_detector_model.h5'
    VECTORIZER_CONFIG_PATH = 'text_vectorizer_config.json'

    text_vectorizer = load_and_adapt_text_vectorizer(VECTORIZER_CONFIG_PATH)
    model = load_trained_news_model(MODEL_PATH)
    st.success("Modelo e vetorizador carregados com sucesso!")

    st.write("---")
    st.subheader('Cole o texto da not√≠cia aqui:')
    user_news_input = st.text_area("", height=250, placeholder="Ex: Cientistas descobrem cidade perdida em Marte...")

    if st.button('Classificar Not√≠cia'):
        if user_news_input:
            with st.spinner('Analisando...'):
                predicted_class, prediction_prob, df_results = predict_news_sentiment(model, text_vectorizer, user_news_input)

                st.subheader("Resultado da An√°lise:")
                if predicted_class == "REAL":
                    st.success(f"**Esta not√≠cia √© REAL!** (Probabilidade de ser Real: {prediction_prob*100:.2f}%)")
                    st.balloons()
                else:
                    st.error(f"**Esta not√≠cia √© FALSA!** (Probabilidade de ser Falsa: {(1-prediction_prob)*100:.2f}%)")
                    st.snow()

                # Exibir as probabilidades detalhadas como uma tabela (opcional, ou pode ser um gr√°fico de barras)
                st.write("---")
                st.subheader("Probabilidades Detalhadas:")
                st.dataframe(df_results.set_index('Classes')) # Exibe o DataFrame

                # Se voc√™ quiser um gr√°fico de barras como no seu exemplo (necessita plotly.express)
                # import plotly.express as px
                # fig = px.bar(df_results, x='Probabilidades (%)', y='Classes', orientation='h',
                #              title='Confian√ßa do Modelo', text='Probabilidades (%)')
                # fig.update_traces(texttemplate='%{text:.2f}%', textposition='outside')
                # st.plotly_chart(fig, use_container_width=True)

        else:
            st.warning('Por favor, digite ou cole o texto de uma not√≠cia para classificar.')

    st.markdown("---")
    st.write("Desenvolvido com TensorFlow e Streamlit")
    st.write("Para treinar o modelo, execute `python model_trainer.py` primeiro.")

if __name__ == "__main__":
    main()